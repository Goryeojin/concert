## 1. 개요   
> 콘서트 예약 시스템의 트랜잭션 범위를 이해하고, 시스템의 서비스 확장 및 **MSA(Microservices Architecture)**로의 전환을 고려한 서비스 분리 및 분산 트랜잭션 처리 방법을 설계합니다.   
> 시스템 규모가 커지면서 각 기능을 독립적인 서비스로 분리하고, 그에 따른 트랜잭션 관리 방안을 다루며, 트랜잭션 처리의 한계와 이를 해결하기 위한 방법을 제시합니다.

## 2. 현재 시스템 분석
### 2.1. 현재 시스템의 트랜잭션 범위
현재 모놀리식 시스템에서 콘서트 예약과 결제, 포인트 차감 등 여러 비즈니스 로직은 하나의 트랜잭션 내에서 처리됩니다.

#### 예약 처리
사용자 예약 요청 시, 좌석 예약 정보가 DB에 저장됩니다.
예약된 정보는 `Reservation` 테이블에 저장됩니다.
예약 상태 변경이 이뤄지며, 예약이 완료된 상태로 업데이트됩니다.

#### 결제 처리
결제 요청이 들어오면, 사용자 포인트가 차감되고, 결제 정보는 `Payment` 테이블에 저장됩니다.
결제 성공 시, 예약 상태가 `COMPLETED`로 업데이트됩니다.

#### 포인트 처리
결제와 함께 포인트 차감이 이루어집니다.
위의 트랜잭션은 하나의 서비스 안에서 동기적으로 처리되며, 모든 작업이 완료되어야만 트랜잭션이 커밋됩니다.

## 3. 서비스 확장과 MSA로의 전환
### 3.1. 서비스 분리
MSA로 전환하면, 시스템을 여러 독립적인 서비스로 분리해야 합니다. 각 서비스는 자신의 트랜잭션 범위를 가지며, 데이터베이스도 독립적입니다. 이를 통해 각 서비스가 독립적으로 운영될 수 있습니다.

#### 주요 서비스 분리 계획
- 예약 서비스 (Reservation Service)
예약 관련 비즈니스 로직을 담당합니다.
예약 상태 변경, 예약 내역 조회, 좌석 예약 등.

- 결제 서비스 (Payment Service):
결제 처리 및 결제 내역 기록을 담당합니다.
결제 승인, 결제 내역 저장, 포인트 차감 등.

- 포인트 서비스 (Point Service):
사용자 포인트 관리 및 포인트 충전/차감을 처리합니다.
포인트 차감, 포인트 이력 관리 등.

- 이벤트 서비스 (Event Service):
결제 완료 후 이벤트 전송을 담당합니다.
결제 완료 시 외부 시스템으로 결제 내역을 전송합니다.

- 사용자 서비스 (User Service):
사용자 관리와 인증 기능을 담당합니다.
사용자 정보 조회 및 인증, 권한 관리 등.

### 3.2. 서비스 분리의 장점
- 독립적인 배포: 각 서비스는 독립적으로 배포될 수 있어, 서비스 간의 업데이트 충돌을 방지할 수 있습니다.
- 독립적인 확장성: 트래픽에 맞춰 각 서비스를 개별적으로 확장할 수 있습니다. 예를 들어, 결제 서비스가 트래픽이 급증할 때, 결제 서비스만 별도로 확장할 수 있습니다.
- 유지보수 용이성: 각 서비스가 독립적이므로, 단위 테스트와 배포가 더 쉬워집니다.

## 4. 트랜잭션 처리 한계 및 해결 방안
> MSA로 분리된 각 서비스가 독립적인 트랜잭션을 처리할 때, 트랜잭션의 일관성을 유지하는 것이 큰 도전 과제가 됩니다.   
> 서비스 간에 ACID 트랜잭션을 보장할 수 없으므로, 분산 트랜잭션 관리 방안을 고려해야 합니다.

### 4.1. 트랜잭션 처리 한계
- ACID 트랜잭션 불가능
각 서비스가 독립적인 데이터베이스를 사용하므로, 단일 트랜잭션으로 모든 서비스의 데이터를 일관되게 처리하는 것이 불가능합니다.
트랜잭션 범위가 여러 서비스로 확장되므로 동기화가 필요합니다.

- 일관성 유지 문제
결제 서비스에서 결제가 완료되었지만, 예약 서비스에서 예약 상태 변경이 실패하는 경우와 같은 부분 실패가 발생할 수 있습니다.
보상 작업(Compensating Transactions)을 어떻게 설계할지에 대한 고민이 필요합니다.

- 네트워크 지연
서비스 간에 HTTP, 메시지 큐 등을 통해 통신하면서 발생할 수 있는 지연으로 인해 트랜잭션 처리 시간이 길어질 수 있습니다.

### 4.2. 해결 방안
#### SAGA 패턴 (Saga Pattern)
MSA에서 분산 트랜잭션을 처리하는 가장 일반적인 방법은 SAGA 패턴을 사용하는 것입니다. 각 서비스는 작은 트랜잭션을 수행하고, 실패 시에는 보상 작업을 통해 이전 상태를 복구합니다.   
SAGA 패턴은 트랜잭션을 작은 단계로 나누어 독립적으로 실행하고, 각 서비스가 완료되면 다음 서비스를 호출하는 방식으로 구현됩니다.   
보상 작업은 트랜잭션이 실패할 경우 이전 단계를 취소하는 방식으로 일관성을 유지합니다.   
서비스 간의 이벤트를 통해 상태 변경을 전파하고, 각 서비스는 이벤트 리스너를 통해 다른 서비스와 통신합니다.

#### 이벤트 기반 아키텍처
- 이벤트 발행 및 구독 
각 서비스는 비동기적으로 이벤트를 발행하고 구독합니다.
예를 들어, 예약 서비스에서 예약 완료 후 결제 서비스로 결제 요청 이벤트를 발행하고, 결제 서비스는 이를 수신하여 결제를 처리합니다.

- 메시지 큐
서비스 간 통신을 메시지 큐(예: RabbitMQ, Kafka)를 통해 비동기적으로 처리합니다.
예약 서비스에서 결제 완료 후, 포인트 서비스로 포인트 차감 이벤트를 발행합니다.

- 트랜잭션 상태 모니터링
트랜잭션을 모니터링하고, 실패 시에는 보상 작업을 자동으로 실행할 수 있도록 설계합니다.
데이터 일관성을 보장하기 위해 서비스 간의 트랜잭션 상태를 추적할 수 있는 시스템을 구축합니다.

- 외부 트랜잭션 관리 시스템
외부 트랜잭션 관리 시스템(예: Atomikos, Narayana)을 사용하여 분산 트랜잭션을 관리할 수 있습니다.
다만, 분산 트랜잭션 관리 시스템을 사용하는 경우, 성능에 영향을 미칠 수 있으므로 비즈니스 요구 사항에 맞는 최적화가 필요합니다.

## 5. 결론
MSA로의 전환은 서비스 간 독립성을 증가시키고 확장성을 개선할 수 있는 장점이 있습니다.  
그러나 분산 트랜잭션 관리의 문제는 MSA로 전환하는 과정에서 중요한 고려 사항이 됩니다.  
SAGA 패턴을 사용한 이벤트 기반 아키텍처는 서비스 간 일관성을 유지하는 데 유효한 해결책이 될 수 있습니다.  
각 서비스가 독립적으로 트랜잭션을 관리하면서도, 트랜잭션의 일관성을 보장하기 위해서는 보상 작업 및 상태 추적 시스템을 잘 설계하는 것이 중요합니다.